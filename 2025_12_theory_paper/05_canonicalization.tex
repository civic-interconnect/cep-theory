% !TeX root = 00_cep_semantics.tex

\section{Canonicalization as a Monoidal Functor}
\label{sec:canonicalization}

Canonicalization is the mathematical process that ensures the stability
and uniqueness of the SNFEI identifier.
In the Civic Exchange Protocol (CEP), normalization and assembly are
expressed as a structured rewriting system and modeled categorically
as a composite of functors equipped with
a strict monoidal structure.

% ----------------------------------------------------------------------
\paragraph{Ordering of Rewrite Rules.}

We regard normalization as a total function
\[
  \mathrm{norm} : \mathrm{RawString} \to \mathrm{CanonicalString}.
\]
Rewrite operations occur at three levels: (1)~semantic expansions,
(2)~structural simplifications, and (3)~surface-level normalizations.
Some rewrites preserve information while others reduce it, so their order
is essential.
For example, the corporate form ``S.A.'' must be expanded
before punctuation is removed; otherwise the pattern disappears and the
expansion cannot apply.

CEP adopts a \emph{stratified} rewriting system with a fixed ordering of
rule strata.
Rewrite rules compose associatively within each stratum.
Across strata, the ordering is not assumed to commute and is treated as
part of the definition of the normalization pipeline.

This behavior is representative rather than exceptional: whenever a
semantic rewrite depends on surface structure, rewrite order becomes
semantically meaningful and cannot be treated as commutative.


% ----------------------------------------------------------------------
\subsubsection{Stratified Canonicalization as a Functor}

Let $\Raw$ be the set of raw strings and $\Canon$ the set of canonical
forms, viewed as a quotient of $\Raw$ under an equivalence relation that
identifies strings representing the same civic entity.
Let
\[
  q : \Raw \to \Canon
\]
be the quotient map selecting canonical representatives.

Normalization is implemented by a finite sequence of rewrite functions
\[
  n_1, n_2, \dots, n_k : \Raw \to \Raw,
\]
each belonging to a particular stratum.
Within a stratum composition is
associative; across strata the evaluation order is fixed.
The overall normalization map is
\[
  \mathrm{norm}
  \;=\;
  q \circ n_k \circ \dots \circ n_2 \circ n_1
  : \Raw \to \Canon.
\]

Categorically, each $n_i$ is an endomorphism of $\Raw$ in $\mathbf{Set}$.
The rule strata form a thin (preordered) category $\mathcal{S}$.
The normalization pipeline is a functor
\[
  F : \mathcal{S} \to \mathbf{End}(\Raw),
\]
where $\mathbf{End}(\Raw)$ is the monoidal category of endofunctions on
$\Raw$ under composition.
The fixed order of $\mathcal{S}$ determines the
evaluation of the composite; commutativity is not required.

% ----------------------------------------------------------------------
\paragraph{Diagrammatic View.}

\[
  \begin{tikzcd}
    \Raw \arrow[r, "n_1"]
    \arrow[rr, bend left=30, "n_2 \circ n_1"]
    \arrow[rrr, bend left=45, "n_3 \circ n_2 \circ n_1"]
    &
    \Raw \arrow[r, "n_2"]
    &
    \Raw \arrow[r, "n_3"]
    &
    \Raw \arrow[r, "q"]
    &
    \Canon
  \end{tikzcd}
\]

Associativity of composition gives
\[
  (n_3 \circ n_2) \circ n_1 = n_3 \circ (n_2 \circ n_1),
  \qquad
  \mathrm{norm} = q \circ n_3 \circ n_2 \circ n_1.
\]
Stratification appears as the requirement that the arrows $n_i$ occur in a
fixed left-to-right order.

% ----------------------------------------------------------------------
\paragraph{Relation to Rewriting Systems.}

Many established rewriting systems use ordered or strategy-driven rule
application.
Classical completion procedures, modern term-rewriting
frameworks, compiler pipelines, natural-language normalization workflows,
and Unicode normalization all apply structured, multi-stage rewriting in
which information-preserving rewrites precede information-reducing ones.

CEP follows this standard pattern.
Each stratum contains rewrite rules that compose cleanly within their domain,
while the fixed ordering across strata functions as the evaluation strategy
that guarantees determinism of the composite normalization function.

This strategy-controlled evaluation means that CEP canonicalization is not
intended to be confluent or transitive with respect to individual rewrite rules.
Only the fully evaluated composite function norm defines the canonical equivalence
relation.

% ----------------------------------------------------------------------
\subsubsection{Rewriting Systems as 2-Categories}

Rewriting systems may be described in terms of 2-categories or polygraphs:
objects are syntactic states, 1-morphisms are rewrite steps, and
2-morphisms represent coherence between rewrite paths.
Normalization corresponds to selecting a distinguished representative of each connected
component of the 1-skeleton.

CEP fits this model.
Each stratum consists of 1-morphisms that are closed
under associative composition, while the ordering of strata specifies a
deterministic rewriting strategy.
The normalization map
\[
  \mathrm{norm} : \Raw \to \Canon
\]
is therefore a strategy-controlled composite followed by quotienting.

% ======================================================================
\subsection{The Normalizing Functor
  \texorpdfstring{$\mathcal{F}_{\mathrm{normalize}}$}{F\_normalize}}
% ======================================================================

Let $\mathbf{R}_{\text{raw}}$ be the category whose objects are raw
record states and whose morphisms are valid transformations between them.
Let $\mathbf{R}_{\text{canon}}$ be the corresponding category of
canonical states.

Normalization is a functor
\begin{equation}
  \mathcal{F}_{\mathrm{normalize}} :
  \mathbf{R}_{\text{raw}} \to \mathbf{R}_{\text{canon}}.
\end{equation}

For any morphism $f : R \to R'$ in $\mathbf{R}_{\text{raw}}$, functoriality
ensures that
\[
  \mathcal{F}_{\mathrm{normalize}}(f) :
  \mathcal{F}_{\mathrm{normalize}}(R)
  \to
  \mathcal{F}_{\mathrm{normalize}}(R')
\]
is the corresponding update on canonical records.

% ======================================================================
\subsection{Monoidal Structure and the Canonicalization Functor
  \texorpdfstring{$\mathcal{C}$}{C}}
% ======================================================================

Let $\mathbf{R}_{\text{canon}}$ carry a monoidal structure in which
objects represent normalized components and $\otimes$ denotes their
ordered concatenation.
Let $\mathbf{C}$ be the category of canonical strings with monoidal product
also given by concatenation and unit $I$.

The assembly step is a strict monoidal functor
\begin{equation}
  \mathcal{C} : (\mathbf{R}_{\text{canon}}, \otimes, I)
  \to (\mathbf{C}, \otimes, I)
\end{equation}
satisfying
\begin{equation}
  \mathcal{C}(x \otimes y) = \mathcal{C}(x) \otimes \mathcal{C}(y),
  \qquad
  \mathcal{C}(I) = I.
\end{equation}

This functor performs the disciplined concatenation that assembles
canonical parts (name, address, date, jurisdiction) into a single string
in the fixed order prescribed by CEP.

% ======================================================================
\subsection{From Canonical Strings to SNFEI}
% ======================================================================

Let
\[
  H : \mathbf{C} \to \mathbf{ID}
\]
be the hashing functor that maps canonical strings to 256-bit identifiers
via the SHA-256 cryptographic hash function.
For a record $R$,
\[
  \mathrm{SNFEI}(R)
  =
  H\!\left(\mathcal{C}(R_{\text{canon}})\right),
  \qquad
  R_{\text{canon}} =
  \mathcal{F}_{\mathrm{normalize}}(R_{\text{raw}}).
\]

The full pipeline is the composite functor
\begin{equation}
  H \circ \mathcal{C} \circ \mathcal{F}_{\mathrm{normalize}}
  : \mathbf{R}_{\text{raw}} \to \mathbf{ID}.
\end{equation}

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[node distance=3.5cm,>=Stealth]
    \node (raw)   {$\mathbf{R}_{\text{raw}}$};
    \node (canon) [right of=raw] {$\mathbf{R}_{\text{canon}}$};
    \node (C)     [right of=canon] {$\mathbf{C}$};
    \node (id)    [right of=C] {$\mathbf{ID}$};

    \draw[->] (raw)   -- node[above]
    {$\mathcal{F}_{\mathrm{normalize}}$} (canon);
    \draw[->] (canon) -- node[above]
    {$\mathcal{C}$} (C);
    \draw[->] (C)     -- node[above]
    {$H$} (id);
  \end{tikzpicture}
  \caption{Canonicalization pipeline from raw records to stable identifiers.}
  \label{fig:canonicalization-pipeline}
\end{figure}

% ======================================================================
\subsection{Identifier Invariance and Equivalence Classes}
% ======================================================================

\textbf{Invariance Principle.}
If $f : R \to R'$ is an identity-preserving morphism in the category
$\mathbf{CEP}$ of valid CEP record states and updates, then
\[
  H \circ \mathcal{C} \circ \mathcal{F}_{\mathrm{normalize}}(R)
  =
  H \circ \mathcal{C} \circ \mathcal{F}_{\mathrm{normalize}}(R').
\]

Identity-preserving updates therefore do not change the SNFEI.
Two record states lie in the same equivalence class precisely when they produce the
same canonical string and hence the same identifier.
Strict monoidality of $\mathcal{C}$ ensures that required components appear in the correct
order and cannot be reordered or omitted along valid CEP morphisms.

\FigureCallout{Canonicalization as a Monoidal Functor and Identity Guarantee}{
  Because $\mathcal{F}_{\mathrm{normalize}}$ and $\mathcal{C}$ are
  functorial, and $\mathcal{C}$ is strictly monoidal, the canonical string
  associated with an entity is uniquely determined by its
  identity-bearing fields.
  The SNFEI is therefore a function of an equivalence class of records
  rather than any particular representation.}

This invariance principle underpins CEP's claims of stable,
provenance-respecting identifiers suitable for cross-jurisdiction
linkage and data fusion.